#!/bin/bash
set -e

cmd="$1"

if test ! "$cmd"; then
    echo "command required."
    echo
    echo "available commands:"
    echo "  build           build project"
    echo "  clean           deletes all generated files"
    echo "  cpu-graph       launches Go's profile visualiser"
    echo "  release         build project for distribution"
    echo "  test            run tests"
    echo "  test.coverage   run tests, then show coverage report"
    echo "  update-deps     update project dependencies"
    exit 1
fi

shift
rest=$*

if test "$cmd" = "build"; then
    # CGO_ENABLED=0 skips CGO and linking against glibc to build static binaries.
    # -v 'verbose'
    CGO_ENABLED=0 go build \
        -v
    exit 0

elif test "$cmd" = "clean"; then
    # validate-article-json - generated by Go because of go.mod.
    # linux-amd64* linux-arm64* - generated by the 'release' command.
    # coverage.out coverage.html - generated by the 'test.coverage' command.
    rm -fv validate-article-json linux-amd64* linux-arm64* coverage.*
    exit 0

elif test "$cmd" = "cpu-graph"; then
    go tool pprof -http 127.0.0.1:1236 cpu.prof
    exit 0

elif test "$cmd" = "release"; then
    # GOOS is 'Go OS' and is being explicit in which OS to build for.
    # CGO_ENABLED=0 skips CGO and linking against glibc to build static binaries.
    # ld -s is 'disable symbol table'
    # ld -w is 'disable DWARF generation'
    # -trimpath removes leading paths to source files
    # -v 'verbose'
    # -pgo 'profile-guided-optimisation' using the cpu profile 'cpu.prof'
    # -o 'output'
    GOOS=linux GOARCH=amd64 CGO_ENABLED=0 go build \
        -ldflags="-s -w" \
        -trimpath \
        -v \
        -pgo cpu.prof \
        -o linux-amd64
    sha256sum linux-amd64 > linux-amd64.sha256

    GOOS=linux GOARCH=arm64 CGO_ENABLED=0 go build \
        -ldflags="-s -w" \
        -trimpath \
        -v \
        -pgo cpu.prof \
        -o linux-arm64
    sha256sum linux-arm64 > linux-arm64.sha256

    echo ---
    echo "wrote linux-amd64"
    echo "wrote linux-amd64.sha256"
    echo "wrote linux-arm64"
    echo "wrote linux-arm64.sha256"
    exit 0

elif test "$cmd" = "test"; then
    # CGO_ENABLED=0 skips CGO and linking against glibc to build static binaries.
    # -v verbose
    CGO_ENABLED=0 go test \
        -v \
        ./...
    exit 0

elif test "$cmd" = "test.coverage"; then
    # CGO_ENABLED=0 skips CGO and linking against glibc to build static binaries.
    # -cover 'enable coverage analysis'
    # -coverprofile 'write a coverage profile to the file'
    CGO_ENABLED=0 go test \
        -cover \
        -coverprofile=coverage.out \
        ./...
    # -html 'generate HTML representation of coverage profile'
    # -o 'file for output'
    go tool cover -html=coverage.out -o coverage.html
    # -func 'output coverage profile information for each function'
    go tool cover -func=coverage.out
    echo "wrote coverage.out"
    echo "wrote coverage.html"
    exit 0

elif test "$cmd" = "update-deps"; then
    # -u 'update modules [...] to use newer minor or patch releases when available'
    go get -u
    go mod tidy
    ./manage.sh build
    exit 0

# ...

fi

echo "unknown command: $cmd"
exit 1
